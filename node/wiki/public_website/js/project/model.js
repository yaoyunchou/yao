// TODO: make content-directory part of 'shared'

define(['underscore'], function(_)
{
	var Model = function()
	{
		var GENERIC_TITLE = 'wiki';

		// This is the main data structure, which comes from the service.
		// It is an array of Objects and nested arrays.
		var _items = [];

		var _title;
		var _defaultDocumentId;
		var _exportedMimeTypes;
		var _utcTime;
		var _recentChanges;

		// Hash where key is id and value is the file item object.
		// Derived from _items. Used for file item lookups.
		var _flatMap;

		// ---

		this.load = function(url, callback) {
			
			// The model data is generated by the accompanying node.js app.
			// Rem, its tree structure has already been sorted - folders first, and files in alpha.

		    $.getJSON(url, function(o) {
		    
		    	if (! $.isArray(o.items)) {
		    		callback(new Error("Load error - bad data"))
		    		return;
		    	}

				_items = o.items;
				initFlatMap();

				_title = o.title || GENERIC_TITLE;
				_defaultDocumentId = o.defaultDocumentId;
				_exportedMimeTypes = o.exportedMimeTypes;
				_utcTime = o.utcTime;
				_recentChanges = o.recentChanges;

				console.log('model data loaded');

		    	callback();
		    })
			.fail(function() {
				callback(new Error("Load error - file"));
			});
		};

		this.items = function () { 
			return _items; 
		};

		this.title = function () {
			return _title;
		}

		this.defaultDocumentId = function () {
			return _defaultDocumentId;
		};

		this.exportedMimeTypes = function () {
			return _exportedMimeTypes;
		};

		this.utcTime = function () {
			return _utcTime;
		};

		this.recentChanges = function () {
			return _recentChanges;
		};

		this.itemById = function(id) {
			return _flatMap[id];
		};

		// Returns an array of arrays, of each enclosing 'folder' of item-with-id,
		// starting from the outermost folder to the one actually containing the item.
		// There was a better way of doing this. 
		//
		this.getHolderArraysOfItemWithId = function(id) {


			if (id == _items[0].id) return [];  // id is of root folder itself so return nothing

			var arrays = [];

			// the first element is always the root folder; we'll recurse 'into' the tree
			arrays.push(_items);  
			
			var base = _items;

			while (true)
			{
				var result = findNextHolderArrayOfItem(base, id);
				
				if (! result) return arrays;  // can only happen if no such id, i think

				if (result[0].id == id) return arrays;  // this happens at the end when the item of the id is itself a folder

				var lastResult = (arrays.length > 0) ? arrays[arrays.length-1] : null;
				if (result == lastResult) return arrays; // done

				// console.log('getHolderArraysOfItemWithId() lv.' + arrays.length + ": ", result[0].title);
				
				arrays.push(result);
				base = result;

				if (arrays.length > 50) { util.assert('infinite loop. check logic.'); return;}
			}
		};

		// Returns the immediate child array of 'a' that contains item with id (which could be extra levels deep).
		//
		var findNextHolderArrayOfItem = function (a, id) {

			for (var i = 0; i < a.length; i++)
			{
				var el = a[i];
				if (el.id == id) {
					return a;
				}
				if ($.isArray(el)) {
					var o2 = findNextHolderArrayOfItem(el, id);
					if (o2) return el;
				} 
			}
		};

		var initFlatMap = function () {

			_flatMap = {};

			var addItems = function(a) {

				// skipping 1st element, which is always a folder item
				for (var i = 1; i < a.length; i++) {
					var item = a[i];
					if ($.isArray(item)) {
						addItems(item);

					}
					else if (item.type == 'document') {
						// any Object after 1st element _must_ be a document not a folder, but anyway
						_flatMap[item.id] = item;
					}
				}
			}

			addItems(_items);

			// for (var id in _flatMap) { console.log('flatmap', id, _flatMap[id].title); }
		}

		/**
		 * @returns  	eg, 'wiki/java-related/android/'
		 */
		this.makeCrumbStringOfItem = function(item, includingSelf) {

			var a = this.getHolderArraysOfItemWithId(item.id);
			if (! a || a.length == 0) return null;

			var s = '';
			_.each(a, function (folderArray) {
				var folderItem = folderArray[0];
				if (! folderItem) return null; // shouldn't happen
				s += folderItem.title + '/';
			});
			if (includingSelf) s += item.title;

			return s;
		};
	};

	// ---------------------------
	// 'static' functions

	// ...


	return Model;
});


// This (recursive) version no longer needed
/*
this.findItemById = function(id, array) {

	array = array || _items;

	 for (var i = 0; i < array.length; i++)
	 {
	 	var el = array[i];
 		if (! $.isArray(el)) {
 			if (el.id == id) {
 				return el;
 			}
 		} 
 		else {
 			var a = this.findItemById (id, el);
 			if (a) return a;
 		}
	 }
};
*/